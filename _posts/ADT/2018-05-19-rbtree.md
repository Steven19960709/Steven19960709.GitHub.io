---
layout: post
title: BBST之红黑树
tags: [ADT]
date: 2018-05-19
---

## 红黑树

红黑树是BBST的一个新类型。线性结构：向量，列表，栈，队列，或是半线性结构的树，非线性结构图。它们都是随时变化的，某一个状态只会存在一瞬间。

但是如果要记录每一个瞬间（快照）需要创建副本，累计消耗O(h+n)的时间和空间。这个显然不能接受，但是要实现O(n+h*logn)这个复杂度，就需要使用不同版本之间的关联性。

我们可以采用这种策略，需要大量共享，少量变化进行更新。每个版本的新增复杂度，仅为O(logn)。

<img src="http://os310ujuc.bkt.clouddn.com/rbt2.png">

### 结构

红黑树，首先必须是真二叉树，每个节点都是非1节点。有红黑节点组成。

- 树根必须为黑色
- 外部节点均为黑色
- 其余节点：若为红色，则只能有黑孩子。 // 红之子，之父必为黑
- 外部节点到根：图中黑节点数目相等 ，即为黑深度

<img src="http://os310ujuc.bkt.clouddn.com/rbt3.png">

图中已经为所有需要的节点添加外界点，即黑节点，但是不标出。

对于第一点，根节点是黑色的，对于第二点，红色的末端节点已经做过预处理，为所有的需要的节点添加外部节点，实际上并不存在，所以已经忽略。对于第三条，每一个红节点其父亲都是黑节点，对于末端叶节点，外部节点也是黑节点（没有标出）。对于第四点，外部节点带根节点，都是为3个黑节点，同样符合。

#### 提升变换

变换前：<img src="http://os310ujuc.bkt.clouddn.com/rbt4.png">

变换后：<img src="http://os310ujuc.bkt.clouddn.com/rbt5.png">


对每一个红色节点都进行提升到黑节点的同级。如图变化。

提升变换之后，所有底层的节点都变成了沿同一水平平齐的高度。

红黑树就是4阶的B树。

<img src="http://os310ujuc.bkt.clouddn.com/rbt6.png">

由等价性的，既然B树是平衡的，红黑树自然也是平衡的。高度h=O(logn).

通过多少个黑节点就是多少黑深度。不能出现相邻的红色节点。得红色高度不得超过黑高度两倍。

<img src="http://os310ujuc.bkt.clouddn.com/rbt.png">

### 接口定义

<img src="http://os310ujuc.bkt.clouddn.com/rbt7.png">


#### 插入

借助B树的模型进行操作。在考察每一个红黑树的时候需要有B树的概念。与所有的BBST一样，变换之后，拓补结构通常会发生改变。通过影子树的概念，

红黑树的各条规则尽量满足。所有的数根节点和外部节点都是黑色的。但是对于第三条规则未必满足，对于末端叶节点都是黑色的，但是父节点不确定。凡是指向黑色节点，用实线表示，禁止父子节点都是红色（双红缺陷），这个时候需要考察祖父节点（必然存在），节点g比为黑色。相对于节点x，u是叔父节点。

算法框架：

使用查找接口进行定位，然后创建x节点插入其中，初始化为红色。使用solveDoubleRed(x)查看是否为双红缺陷。最后返回。

<img src="http://os310ujuc.bkt.clouddn.com/rbt8.png">

##### 修复

<img src="http://os310ujuc.bkt.clouddn.com/rbt9.png">

根据红节点只能有黑节点的原则，a和b都发生了双红缺陷。这个时候进行合并，变成a'和b'。这个时候没有发生下属的分支都没有超过4阶B树的上限。确切的说，每个剧中的关键码，并不是黑色的，这个是一个缺点。这个时候我们需要对关键码进行会从新染色。

采用三加四重构，按照中序遍历重新命名，进行重染色，b转黑，a或者c砖红。

<img src="http://os310ujuc.bkt.clouddn.com/rbt10.png">

第二种情况就是叔父节点u的节点不是黑色。

<img src="http://os310ujuc.bkt.clouddn.com/rb11.png">

合并，变成4个关键码的超级节点，对应5个分支。但是，这个时候，超级节点发生上溢。这个时候我们就需要上溢缺陷。将原来的大节点，，分裂为两个子节点。

这样一个迂回的理解过程，比较好理解，对于红黑树：只需将节点p油红转黑，节点g由黑转红，而对于B树来说，就是进行一次分裂。

但是在变换之后，仍然可能会出现双红缺陷，同样可以使用节点分裂，颜色转换等方法解决。

最后，全书拓补结构并没有改变，复杂度仍然是logn。

##### 复杂度

重构，染色均属于常数时间的局部操作，所以计算执行了多少次。

<img src="http://os310ujuc.bkt.clouddn.com/rbt12.png">

#### 删除算法

借助提升变换，将红黑树变成B树，关注重构操作。

首先调用BST常规算法，执行r=removeAt。

<img src="http://os310ujuc.bkt.clouddn.com/rbt13.png">

双黑缺陷，x和r都是黑色，但是在4阶B树中，x将发生下溢。

<img src="http://os310ujuc.bkt.clouddn.com/rbt14.png">

##### 修复

第一种情况，r或者是s的兄弟是黑色，且至少有一个红孩子t。

<img src="http://os310ujuc.bkt.clouddn.com/rbt15.png">

首先将此树转化为4阶B树，这个时候可以通过关键码旋转来进行修复。

<img src="http://os310ujuc.bkt.clouddn.com/rbt16.png">

第二种情况：兄弟节点为黑，同时两个孩子都是黑色。而且还能分为两个子情况。对于a，并不能实施旋转调整，不能借出关键码，这个时候要进行合并。最后将这个B树反向变换为红黑树即可。

<img src="http://os310ujuc.bkt.clouddn.com/rbt17.png">

对于兄弟节点为黑色，子节点也为黑。同样是通过子节点的合并来删除。这个时候双黑缺陷可能会进行向上传递。直到树根。

    <img src="http://os310ujuc.bkt.clouddn.com/rbt18.png">

第三种情况，对于兄弟节点为红色的情况，同样是需要站在B树的角度。通过转换跳出BB3的情况，二道BB2的情况。

<img src="http://os310ujuc.bkt.clouddn.com/rbt19.png">

## 总结

每一次删除操作，至多只会消耗常数时间，都在O(logn)时间内完成。

<img src="http://os310ujuc.bkt.clouddn.com/rbt20.png">

BB2R旋转次数为0，BB2B会进行一次重染色，可能会向上传递双黑缺陷。这个时候需要进行重染调整。对于BB3，会转化为BB2r或者是BB1的情况。累计的旋转操作也只是常熟次。