---
layout: post
title:  JavaScript函数和作用域初探
date: 2017-07-18
tags: [JavaScript]
---

大家晚上好，今天继续和大家分享一下JavaScript的知识，今天我要讲的是JavaScript函数和JavaScript的作用域。

## JavaScript函数

先说一下为什么我们需要函数，请看下面这个例子：

        if(1 > 0){
          console.log("a");
          console.log("b");
          console.log("c");
        }
        if(2 > 0){
          console.log("a");
          console.log("b");
          console.log("c");
        }
        if(3 > 0){
          console.log("a");
          console.log("b");
          console.log("c");
        }

我们可以看到，打印出a 、b、c的语句重复了很多次，在编程里面称为耦合（重复），但是这是与编程原则所相违背的，编程要讲究高内聚，弱耦合，我们需要将它们都整合到一起，这时候就出现了函数了。

我们可以定义一个函数，当符合条件的时候就让这个函数执行，请看优化后的代码：

        function test(){
          console.log("a");
          console.log("b");
          console.log("c");
        }
        if(1 > 0) {
          test()
          }
        if(2 > 0){
          test();
        }
        if(3 > 0){
          test();
        }

这样，我们就是耦合程度大大降低了，这也是使用函数的一个重要目的。称之为：解耦合，把功能抽象出来，进行逻辑的处理之后，通过编写函数，达到把耦合程度降到最低。

### 函数的定义方式 

函数有最基本几个要素： 声明关键词：function， 函数名称， 参数（可选）。

函数的命名方式，是有规范的，如果多个单词进行拼接的时候，我们需要使用小驼峰式命名，即第一个单词小写，之后的每个单词首字母大写。例如

function theFirstName()

说完函数的命名方式之后，我们需要知道怎样对函数进行定义。

1.函数声明方式，形如 ：

        function name() { code } 。

以这样方式声明的函数，我们称之为函数声明方式。它是采用function并直接加上函数名字来进行声明，注意的是，名字后面的括号和花括号是不能省略的。

 2.函数表达式方式：形如 ：   
 
        1 , var test = function demo() { code } , 函数表达式

        2,  var test = function () { code } , 匿名函数表达式
                        
                        
当我们在控制台调试的时候，我们可以发现第一种方法，利用test ，可以寻找到该函数，但是利用函数的名字demo，却会报错。第二种方法直接利用test就可以寻找到该函数，这表明了，函数表达式的demo这个名字，其实填写和不填写是一样的，因为在JavaScript内部，会将函数表达式最后都转化为 匿名函数表达式，所以我们统一采用匿名函数表达式，并称之为：函数表达式。

综上，我们可以看到，函数的组成形式就是：function + 函数名称 + （参数）。

对于参数来说，是参数使得函数变得更加灵活多变，使JavaScript更富有生命力。接下来我们就讲讲，函数的参数。


### 参数

    function test（a, b）{ code } 
    test(1,2)
    
test后面跟着的一个括号就是用来填函数的参数的，这里写上一个a和b，就相当于在函数内部隐式的定义了两个变量a和b，参数不代表实际的值，相当于占位而已，必须是当你传入实际的值的时候，才会有特定的意义。所以我们称之为形式参数，简称形参，然后我们都通过传入1,2，这样就相当于给a赋值1，给b赋值2，这两个实际的值就称之为实际参数，简称实参。

JavaScript的参数机制很强大，它不限制位数，不限制类型。形参和实参都是天生的不定参，两者的长度没有规定相等，你可以形参定义100个，但是实参只传10个，或者形参定义两个，实参传200个都是没有问题的。这里又引出了一个概念：参数列表。

实参列表：arguments[1,2] ,实参列表就是用来存放实际参数的，就是我们传进去的参数，对于test来说，arguments有两位分别是1,2.第二个就是arguments是一个类数组，它有长度，无论形参怎么样，实参都会存储arguments中。

形参列表：test[a,b],实参列表，就是函数名字的类数组，里面存放的就是形参，对于test，里面就是a和b。

要注意的是，形参列表和实参列表之间有个映射关系，这个映射关系必须是两者长度一样的时候才会存在，当这个映射关系存在的时候，如果形参列表发生改变，那么实参列表也会跟着改变。例如：

	function func(a,b){
		a = 2;
		b =3;
		console.log(argements[0]); //2
		console.log(argements[1]); //3
	}
	func(1,2)

可以看出，func传进的参数个数跟形参的个数长度是一样的，所以当a，b改变的时候，形参会发生改变。

但是要注意的是，映射规则必须是要一一对应的时候才会有“你变我就变”，没有一一对应例如，形参个数不等于实参个数，都是没有映射规则的。

### return 关键词

return是用来确定函数的返回值的，例如：

        function demo2 () {
          return 222;
          }

        var func = demo();

        console.log(func)   //222

上述例子当我们执行了demo2 ，那么最后我们得到的就是222，但是有一点要注意的是，必须要在外部有变量接收函数的执行结果。

第二个作用就是，终止函数，即，当引擎解析到return语句的时候，那么该函数会马上停止执行，并返回出return后面的语句。

## 作用域 

作用域是一个很重要的概念，每一个函数代码块都是一个作用域，这里有一个全局作用域和局部作用域的概念。

全局作用域：script下面的作用域都是全局作用域，所有在这个作用域声明的变量都是全局变量。

局部作用域：函数可以生成局部作用域，在函数内部声明的变量称之为局部变量。

全局作用域不能访问到局部作用域里面的变量，局部作用域里可以访问到全局作用域的变量。如果利用房子比作作用域的话，一个大房子就相当于一个全局作用域，每个大房子里面的小房子就相当于局部作用域，小房子可以随时开门去到大房子去寻找自身需要的东西，但是大房子没有小房子的钥匙，只能在自身的空间寻找自身需要的东西。这就是全局作用域和局部作用域的概念。

简单来说就是，外面的不能访问到里面的东西，里面的东西可以访问到外面的东西。来看一下这个例子。

        var a = 1;
        function test(){
            a = 2;
            console.log(a)        //2
        }
        function test2(){
            a = 3;
            console.log(a)        //3
        }

a声明在全局里面，它是全局变量，所以test和test2都能够访问到a这个变量，并进行修改，所以得到结果就是分别打印出2和3.

好吧，今天的分享就到这，希望大家能有所收获。晚安！！
























